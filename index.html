<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Labs a defy.vc company</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            text-align: center;
            pointer-events: none;
        }
        #info a {
            color: rgba(255, 255, 255, 0.6);
            text-decoration: none;
            pointer-events: auto;
            transition: color 0.3s ease, text-decoration 0.3s ease;
        }
        #info a:hover {
            color: rgba(180, 220, 255, 0.9);
            text-decoration: underline;
        }
        #gravity-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(60px, 15vw, 200px);
            font-weight: 900;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: 0.3em;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 10;
            user-select: none;
            text-shadow: 
                0 0 30px rgba(255, 255, 255, 0.5),
                0 0 60px rgba(100, 200, 255, 0.3),
                0 0 100px rgba(100, 200, 255, 0.2);
        }
    </style>


    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LD054FNW17"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LD054FNW17');
</script>
    

</head>
<body>
    <div id="gravity-text">GRAVITY</div>
    <div id="info">Partners: <a href="https://www.linkedin.com/in/kylelibra/">Kyle Libra</a> and <a href="https://www.linkedin.com/in/bartekringwelski/">Bartek Ringwelski</a></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Camera position
        camera.position.z = 5;

        // Particle system configuration
        const particleCount = 3000;
        const sphereRadius = 2;
        const particleSize = 0.0008;

        // Create particle geometry
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const originalPositions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        // Distribute particles on a sphere using fibonacci spiral
        for (let i = 0; i < particleCount; i++) {
            const phi = Math.acos(1 - 2 * (i + 0.5) / particleCount);
            const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);

            const x = sphereRadius * Math.sin(phi) * Math.cos(theta);
            const y = sphereRadius * Math.sin(phi) * Math.sin(theta);
            const z = sphereRadius * Math.cos(phi);

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            originalPositions[i * 3] = x;
            originalPositions[i * 3 + 1] = y;
            originalPositions[i * 3 + 2] = z;

            velocities[i * 3] = 0;
            velocities[i * 3 + 1] = 0;
            velocities[i * 3 + 2] = 0;

            // Color gradient from cyan to magenta based on position
            const hue = (Math.atan2(y, x) + Math.PI) / (2 * Math.PI);
            const color = new THREE.Color().setHSL(hue * 0.3 + 0.5, 0.8, 0.6);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Custom shader material for particles
        const particlesMaterial = new THREE.ShaderMaterial({
            uniforms: {
                pointSize: { value: particleSize * 100 },
            },
            vertexShader: `
                attribute vec3 color;
                varying vec3 vColor;
                uniform float pointSize;
                
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = pointSize * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                
                void main() {
                    float dist = length(gl_PointCoord - vec2(0.5));
                    if (dist > 0.5) discard;
                    
                    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                    vec3 glow = vColor * (1.0 + 0.5 * (1.0 - dist * 2.0));
                    gl_FragColor = vec4(glow, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });

        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // Mouse attractor sphere
        const attractorGeometry = new THREE.SphereGeometry(0.08, 32, 32);
        const attractorMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color1: { value: new THREE.Color(0xff6b6b) },
                color2: { value: new THREE.Color(0xffd93d) },
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 color1;
                uniform vec3 color2;
                varying vec3 vNormal;
                varying vec3 vPosition;
                
                void main() {
                    float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                    vec3 color = mix(color1, color2, fresnel + sin(time * 3.0) * 0.2);
                    float glow = fresnel * 0.8 + 0.4;
                    gl_FragColor = vec4(color * glow, 0.9);
                }
            `,
            transparent: true,
        });

        const attractor = new THREE.Mesh(attractorGeometry, attractorMaterial);
        attractor.position.set(10, 10, 0); // Start off-screen
        scene.add(attractor);

        // Glow effect for attractor
        const glowGeometry = new THREE.SphereGeometry(0.14, 32, 32);
        const glowMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
            },
            vertexShader: `
                varying vec3 vNormal;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vNormal;
                
                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    vec3 color = vec3(1.0, 0.5, 0.3) * intensity * (0.8 + 0.2 * sin(time * 5.0));
                    gl_FragColor = vec4(color, intensity * 0.6);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
        });

        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        attractor.add(glow);

        // Mouse tracking
        const mouse = new THREE.Vector2();
        const mouseWorld = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const intersectPoint = new THREE.Vector3();

        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, intersectPoint);
            mouseWorld.copy(intersectPoint);
        });

        // Touch support
        document.addEventListener('touchmove', (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, intersectPoint);
            mouseWorld.copy(intersectPoint);
        }, { passive: false });

        // Physics parameters
        const gravityStrength = 0.8;
        const returnStrength = 0.02;
        const damping = 0.92;
        const maxDisplacement = 1.5;

        // Animation loop
        let time = 0;
        const tempVec = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Update attractor position with smooth following
            attractor.position.lerp(mouseWorld, 0.15);

            // Update uniforms
            attractorMaterial.uniforms.time.value = time;
            glowMaterial.uniforms.time.value = time;

            // Rotate the particle sphere slowly
            particles.rotation.y += 0.001;
            particles.rotation.x += 0.0005;

            // Update particle positions
            const posArray = particlesGeometry.attributes.position.array;
            const colorArray = particlesGeometry.attributes.color.array;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                // Current position
                const px = posArray[i3];
                const py = posArray[i3 + 1];
                const pz = posArray[i3 + 2];

                // Original position (in world space considering rotation)
                const origX = originalPositions[i3];
                const origY = originalPositions[i3 + 1];
                const origZ = originalPositions[i3 + 2];

                // Transform attractor position to local particle space
                tempVec.copy(attractor.position);
                particles.worldToLocal(tempVec);

                // Distance to attractor
                const dx = tempVec.x - px;
                const dy = tempVec.y - py;
                const dz = tempVec.z - pz;
                const distSq = dx * dx + dy * dy + dz * dz;
                const dist = Math.sqrt(distSq);

                // Gravity force (inverse square law with falloff)
                if (dist > 0.1 && dist < 3) {
                    const force = gravityStrength / (distSq + 0.5);
                    velocities[i3] += (dx / dist) * force;
                    velocities[i3 + 1] += (dy / dist) * force;
                    velocities[i3 + 2] += (dz / dist) * force;
                }

                // Return force to original position
                velocities[i3] += (origX - px) * returnStrength;
                velocities[i3 + 1] += (origY - py) * returnStrength;
                velocities[i3 + 2] += (origZ - pz) * returnStrength;

                // Apply damping
                velocities[i3] *= damping;
                velocities[i3 + 1] *= damping;
                velocities[i3 + 2] *= damping;

                // Update position
                let newX = px + velocities[i3];
                let newY = py + velocities[i3 + 1];
                let newZ = pz + velocities[i3 + 2];

                // Limit displacement from original position
                const dispX = newX - origX;
                const dispY = newY - origY;
                const dispZ = newZ - origZ;
                const dispDist = Math.sqrt(dispX * dispX + dispY * dispY + dispZ * dispZ);

                if (dispDist > maxDisplacement) {
                    const scale = maxDisplacement / dispDist;
                    newX = origX + dispX * scale;
                    newY = origY + dispY * scale;
                    newZ = origZ + dispZ * scale;
                }

                posArray[i3] = newX;
                posArray[i3 + 1] = newY;
                posArray[i3 + 2] = newZ;

                // Update color based on velocity (more motion = brighter)
                const speed = Math.sqrt(
                    velocities[i3] * velocities[i3] +
                    velocities[i3 + 1] * velocities[i3 + 1] +
                    velocities[i3 + 2] * velocities[i3 + 2]
                );
                
                const hue = (Math.atan2(origY, origX) + Math.PI) / (2 * Math.PI);
                const brightness = Math.min(0.6 + speed * 5, 1.0);
                const saturation = 0.8 + speed * 2;
                
                const color = new THREE.Color().setHSL(
                    (hue * 0.3 + 0.5 + speed * 0.5) % 1,
                    Math.min(saturation, 1.0),
                    brightness
                );
                
                colorArray[i3] = color.r;
                colorArray[i3 + 1] = color.g;
                colorArray[i3 + 2] = color.b;
            }

            particlesGeometry.attributes.position.needsUpdate = true;
            particlesGeometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
