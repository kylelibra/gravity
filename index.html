<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Labs</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;1,9..40,300;1,9..40,400&family=DM+Mono:wght@300;400&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        .hero-visualization {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }
        
        .hero-visualization canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .gravity-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(48px, 12vw, 180px);
            font-weight: 900;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: 0.2em;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 10;
            user-select: none;
            text-align: center;
            text-shadow: 
                0 0 30px rgba(255, 255, 255, 0.5),
                0 0 60px rgba(100, 200, 255, 0.3),
                0 0 100px rgba(100, 200, 255, 0.2);
        }
        
        .scroll-indicator {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            opacity: 0.6;
            animation: bounce 2s infinite;
        }
        
        .scroll-indicator span {
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #ffffff;
        }
        
        .scroll-indicator svg {
            width: 24px;
            height: 24px;
            stroke: #ffffff;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
            40% { transform: translateX(-50%) translateY(-10px); }
            60% { transform: translateX(-50%) translateY(-5px); }
        }
    </style>
</head>
<body>
    <header>
        <a href="index.html" class="logo">Gravity Labs</a>
        <nav>
            <a href="about.html">About</a>
            <a href="people.html">People</a>
            <a href="portfolio.html">Portfolio</a>
            <a href="collaborate.html">Collaborate</a>
            <a href="writing.html">Writing</a>
        </nav>
        <div class="hamburger" id="hamburger">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </header>

    <div class="mobile-menu" id="mobileMenu">
        <a href="index.html">Home</a>
        <a href="about.html">About</a>
        <a href="people.html">People</a>
        <a href="portfolio.html">Portfolio</a>
        <a href="collaborate.html">Collaborate</a>
        <a href="writing.html">Writing</a>
    </div>

    <div class="hero-visualization" id="heroVisualization">
        <div class="gravity-text">GRAVITY</div>
        <div class="scroll-indicator">
            <span>Scroll</span>
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 5v14M5 12l7 7 7-7"/>
            </svg>
        </div>
    </div>

    <section id="home">
        <h1>Building with Founders. From the Ground Up.</h1>
        <p class="large">Gravity Labs is a venture studio incubating the next generation of financial technology companies. Fully backed by Defy, we give founders the capital, deep crypto and fintech expertise, and industry network they need to succeed. We support our talent from initial funding to market entry and beyond. Because great companies are built on solid ground.</p>
        <a href="collaborate.html" class="cta-button">Build with Gravity</a>
        
        <div class="home-features">
            <div class="feature">
                <h3>The Defy Promise</h3>
                <p>Gravity Labs is Defy's blockchain-focused incubator, bringing its deep capital resources, institutional credibility, and network of operators and investors to the crypto space.</p><br>
                <div class="stats">
                    <span class="stat">Assets Under Management: $700M</span>
                    <span class="stat">Most Recent Fund: $300M</span>
                </div>
            </div>
            <div class="feature">
                <h3>A Founder-First Approach</h3>
                <p>We recruit exceptional early-stage entrepreneurs for opportunities they're passionate about building. We foster founders with talent and grit, and match their experience with the right idea at the right time.</p>
            </div>
            <div class="feature">
                <h3>The Gravity Labs Ecosystem</h3>
                <p>Your company immediately joins an expert community of strategic partners, advisors, and fellow founders—creating competitive advantages from day one.</p>
            </div>
        </div>
    </section>

    <footer>
        <span class="copyright">© 2026 Gravity Labs. All rights reserved.</span>
    </footer>

    <script>
        const hamburger = document.getElementById('hamburger');
        const mobileMenu = document.getElementById('mobileMenu');
        
        hamburger.addEventListener('click', () => {
            hamburger.classList.toggle('active');
            mobileMenu.classList.toggle('active');
            document.body.style.overflow = mobileMenu.classList.contains('active') ? 'hidden' : '';
        });

        const mobileLinks = mobileMenu.querySelectorAll('a');
        mobileLinks.forEach(link => {
            link.addEventListener('click', () => {
                hamburger.classList.remove('active');
                mobileMenu.classList.remove('active');
                document.body.style.overflow = '';
            });
        });

        const header = document.querySelector('header');
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 100) {
                header.style.borderBottom = '1px solid #333';
            } else {
                header.style.borderBottom = 'none';
            }
        });

        // Three.js Particle Sphere Visualization
        const heroContainer = document.getElementById('heroVisualization');
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        heroContainer.insertBefore(renderer.domElement, heroContainer.firstChild);

        camera.position.z = 5;

        const particleCount = 3000;
        const sphereRadius = 2;
        const particleSize = 0.0008;

        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const originalPositions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const phi = Math.acos(1 - 2 * (i + 0.5) / particleCount);
            const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);

            const x = sphereRadius * Math.sin(phi) * Math.cos(theta);
            const y = sphereRadius * Math.sin(phi) * Math.sin(theta);
            const z = sphereRadius * Math.cos(phi);

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            originalPositions[i * 3] = x;
            originalPositions[i * 3 + 1] = y;
            originalPositions[i * 3 + 2] = z;

            velocities[i * 3] = 0;
            velocities[i * 3 + 1] = 0;
            velocities[i * 3 + 2] = 0;

            const hue = (Math.atan2(y, x) + Math.PI) / (2 * Math.PI);
            const color = new THREE.Color().setHSL(hue * 0.3 + 0.5, 0.8, 0.6);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particlesMaterial = new THREE.ShaderMaterial({
            uniforms: {
                pointSize: { value: particleSize * 100 },
            },
            vertexShader: `
                attribute vec3 color;
                varying vec3 vColor;
                uniform float pointSize;
                
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = pointSize * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                
                void main() {
                    float dist = length(gl_PointCoord - vec2(0.5));
                    if (dist > 0.5) discard;
                    
                    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                    vec3 glow = vColor * (1.0 + 0.5 * (1.0 - dist * 2.0));
                    gl_FragColor = vec4(glow, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });

        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        const attractorGeometry = new THREE.SphereGeometry(0.08, 32, 32);
        const attractorMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color1: { value: new THREE.Color(0xff6b6b) },
                color2: { value: new THREE.Color(0xffd93d) },
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 color1;
                uniform vec3 color2;
                varying vec3 vNormal;
                varying vec3 vPosition;
                
                void main() {
                    float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                    vec3 color = mix(color1, color2, fresnel + sin(time * 3.0) * 0.2);
                    float glow = fresnel * 0.8 + 0.4;
                    gl_FragColor = vec4(color * glow, 0.9);
                }
            `,
            transparent: true,
        });

        const attractor = new THREE.Mesh(attractorGeometry, attractorMaterial);
        attractor.position.set(10, 10, 0);
        scene.add(attractor);

        const glowGeometry = new THREE.SphereGeometry(0.14, 32, 32);
        const glowMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
            },
            vertexShader: `
                varying vec3 vNormal;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vNormal;
                
                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    vec3 color = vec3(1.0, 0.5, 0.3) * intensity * (0.8 + 0.2 * sin(time * 5.0));
                    gl_FragColor = vec4(color, intensity * 0.6);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
        });

        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        attractor.add(glow);

        const mouse = new THREE.Vector2();
        const mouseWorld = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const intersectPoint = new THREE.Vector3();

        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, intersectPoint);
            mouseWorld.copy(intersectPoint);
        });

        document.addEventListener('touchmove', (event) => {
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, intersectPoint);
            mouseWorld.copy(intersectPoint);
        }, { passive: true });

        const gravityStrength = 0.8;
        const returnStrength = 0.02;
        const damping = 0.92;
        const maxDisplacement = 1.5;

        let time = 0;
        const tempVec = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            attractor.position.lerp(mouseWorld, 0.15);

            attractorMaterial.uniforms.time.value = time;
            glowMaterial.uniforms.time.value = time;

            particles.rotation.y += 0.001;
            particles.rotation.x += 0.0005;

            const posArray = particlesGeometry.attributes.position.array;
            const colorArray = particlesGeometry.attributes.color.array;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                const px = posArray[i3];
                const py = posArray[i3 + 1];
                const pz = posArray[i3 + 2];

                const origX = originalPositions[i3];
                const origY = originalPositions[i3 + 1];
                const origZ = originalPositions[i3 + 2];

                tempVec.copy(attractor.position);
                particles.worldToLocal(tempVec);

                const dx = tempVec.x - px;
                const dy = tempVec.y - py;
                const dz = tempVec.z - pz;
                const distSq = dx * dx + dy * dy + dz * dz;
                const dist = Math.sqrt(distSq);

                if (dist > 0.1 && dist < 3) {
                    const force = gravityStrength / (distSq + 0.5);
                    velocities[i3] += (dx / dist) * force;
                    velocities[i3 + 1] += (dy / dist) * force;
                    velocities[i3 + 2] += (dz / dist) * force;
                }

                velocities[i3] += (origX - px) * returnStrength;
                velocities[i3 + 1] += (origY - py) * returnStrength;
                velocities[i3 + 2] += (origZ - pz) * returnStrength;

                velocities[i3] *= damping;
                velocities[i3 + 1] *= damping;
                velocities[i3 + 2] *= damping;

                let newX = px + velocities[i3];
                let newY = py + velocities[i3 + 1];
                let newZ = pz + velocities[i3 + 2];

                const dispX = newX - origX;
                const dispY = newY - origY;
                const dispZ = newZ - origZ;
                const dispDist = Math.sqrt(dispX * dispX + dispY * dispY + dispZ * dispZ);

                if (dispDist > maxDisplacement) {
                    const scale = maxDisplacement / dispDist;
                    newX = origX + dispX * scale;
                    newY = origY + dispY * scale;
                    newZ = origZ + dispZ * scale;
                }

                posArray[i3] = newX;
                posArray[i3 + 1] = newY;
                posArray[i3 + 2] = newZ;

                const speed = Math.sqrt(
                    velocities[i3] * velocities[i3] +
                    velocities[i3 + 1] * velocities[i3 + 1] +
                    velocities[i3 + 2] * velocities[i3 + 2]
                );
                
                const hue = (Math.atan2(origY, origX) + Math.PI) / (2 * Math.PI);
                const brightness = Math.min(0.6 + speed * 5, 1.0);
                const saturation = 0.8 + speed * 2;
                
                const color = new THREE.Color().setHSL(
                    (hue * 0.3 + 0.5 + speed * 0.5) % 1,
                    Math.min(saturation, 1.0),
                    brightness
                );
                
                colorArray[i3] = color.r;
                colorArray[i3 + 1] = color.g;
                colorArray[i3 + 2] = color.b;
            }

            particlesGeometry.attributes.position.needsUpdate = true;
            particlesGeometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
